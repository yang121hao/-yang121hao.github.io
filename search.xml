<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>v2ray开启局域网让手机可以不用挂载代理就上外网</title>
      <link href="posts/6de61336.html"/>
      <url>posts/6de61336.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用v2ray开启局域网让手机可以不用挂载代理就上外网</strong></p><a id="more"></a><h1 id="一、v2ray介绍"><a href="#一、v2ray介绍" class="headerlink" title="一、v2ray介绍"></a><strong>一、v2ray介绍</strong></h1><p>市面上出现最多的词语，VPN，VPS,代理服务器（Proxy），关于这些理解可以查看我准备写的下一篇博客，抛开所有，我来说说v2ray<br>2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。<br>官方中介绍Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。<br>不过从时间上来说，先有 V2Ray 才有 Project V。 如果还是不理解，那么简单地说，V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网（翻墙）学习国外先进科学技术。<br>V2Ray 定位为一个平台，任何开发者都可以利用 V2Ray 提供的模块开发出新的代理软件，所以v2ray就是代理软件</p><h2 id="1、v2ray-简介"><a href="#1、v2ray-简介" class="headerlink" title="1、v2ray 简介"></a>1、v2ray 简介</h2><blockquote><p>V2Ray Windows 客户端主要有两个，一个是 v2ray-core（v2ray 核心，官方客户端），另一个是 v2rayN（基于 v2ray-core 的开一个 GUI 可视化客户端），其中 v2ray-core 可以单独使用，而 v2rayN 则是基于 v2ray-core 的一个辅助可视化工具。</p></blockquote><p>所以推荐V2Ray Windows下面的客户端软件是V2RayN。图形化可视工具，适合新手用户。</p><h2 id="2、V2Ray-Core"><a href="#2、V2Ray-Core" class="headerlink" title="2、V2Ray-Core"></a>2、V2Ray-Core</h2><p>需要注意的是 v2ray-core 区分 32 位和 64 位，大家在选择时注意自己的系统版本。</p><p>官方项目下载地址：<a href="https://github.com/v2fly/v2ray-core">点击访问</a></p><p>官方软件发布地址：<a href="https://github.com/v2ray/v2ray-core/releases">点击访问</a></p><div class="table-container"><table><thead><tr><th>文件名称</th><th>Windows32位下载</th><th>Windows64位下载</th></tr></thead><tbody><tr><td>V2Ray-Core</td><td><a href="https://github.com/v2ray/v2ray-core/releases/download/v4.28.2/v2ray-windows-32.zip">点击下载</a></td><td><a href="https://github.com/v2ray/v2ray-core/releases/download/v4.28.2/v2ray-windows-64.zip">点击下载</a></td></tr></tbody></table></div><h2 id="3、V2RayN-（推荐）"><a href="#3、V2RayN-（推荐）" class="headerlink" title="3、V2RayN （推荐）"></a>3、V2RayN （推荐）</h2><p>v2rayN 是基于官方 v2ray-core 的一个 V2Ray GUI 客户端，提供可视化界面，非常方便。使用时只需要将 v2rayN.exe 拖入到 V2Ray-core 文件夹内即可。</p><p>若是下载的完整版，即可解压直接使用。</p><p>官方项目发布地址：<a href="https://github.com/2dust/v2rayN">点击访问</a></p><p>官方软件发布地址：<a href="https://github.com/2dust/v2rayN/releases/">点击访问</a><br>| 文件名称 | V2RayN文件下载 | V2RayN-Core 完整（带运行环境）下载 |<br>| ——— | ——— | ——— |<br>| V2Ray-Core | <a href="https://github.com/2dust/v2rayN/releases/download/3.23/v2rayN.zip">点击下载</a> | <a href="https://github.com/2dust/v2rayN/releases/download/3.23/v2rayN-Core.zip">点击下载</a> |</p><p><img src="/images/2020-09-30_113145.png" alt="界面"></p><h1 id="二、v2ray开启局域网"><a href="#二、v2ray开启局域网" class="headerlink" title="二、v2ray开启局域网"></a>二、v2ray开启局域网</h1><p>平台：一台PC或其他（软件能够开启共享），一台iphone或安卓或PC等等进行局域网蹭网<br>工具：V2rayN（我在windows平台使用这个，其他平台只要有开启共享设置都一样）</p><p>操作很简单！我就不用语言表达，直接上图。</p><h2 id="1、查询自己ip"><a href="#1、查询自己ip" class="headerlink" title="1、查询自己ip"></a>1、查询自己ip</h2><p>不会查询自己ip的向下看，会查询的跳过直接进入第二节<br><img src="/images/2020-09-30_103349.png" alt="v2ray设置"></p><p><img src="/images/2020-09-30_103444.png" alt="v2ray设置"></p><p><img src="/images/2020-09-30_103537.png" alt="v2ray设置"></p><h2 id="2、v2ray设置"><a href="#2、v2ray设置" class="headerlink" title="2、v2ray设置"></a>2、v2ray设置</h2><p><img src="/images/2020-09-30_102333.png" alt="v2ray设置"></p><p><img src="/images/2020-09-30_102409.png" alt="v2ray设置"></p><p><img src="/images/2020-09-30_102419.png" alt="v2ray设置"></p><p><img src="/images/2020-09-30_103028.png" alt="v2ray设置"></p><p>v2ray设置完基本上就开启了局域网共享，所以接下来就是用手机连接的教程，<strong>我不推荐</strong>PC端连接局域网共享这个<br>有PC端的最好直接使用软件代理</p><h2 id="3、Android配置代理"><a href="#3、Android配置代理" class="headerlink" title="3、Android配置代理"></a>3、Android配置代理</h2><p>我申明这里使用的是华为荣耀9机型，关于别的机型，可以自己百度一下。<br>连接WiFi以后<br><img src="/images/微信图片_20200930105745.jpg" alt="Android设置"></p><p><img src="/images/微信图片_20200930105738.jpg" alt="Android设置"></p><p><img src="/images/微信图片_20200930105734.jpg" alt="Android设置"></p><p><img src="/images/微信图片_20200930105726.jpg" alt="Android设置"></p><h2 id="4、IOS配置代理"><a href="#4、IOS配置代理" class="headerlink" title="4、IOS配置代理"></a>4、IOS配置代理</h2><p><img src="/images/微信图片_20200930102455.png" alt="Android设置"></p><p><img src="/images/微信图片_20200930102502.png" alt="Android设置"></p><p><img src="/images/微信图片_20200930102507.png" alt="Android设置"></p><p><img src="/images/微信图片_20200930102511.png" alt="Android设置"></p><p>这里以后基本上就可以遨游外网，一定要记住是同一局域网下<strong>一定要将电脑打开，运行软件</strong>如果电脑关闭以后发现自己的WiFi用不了可以忘记WiFi重新登录，也可以将那个图片中的代理换成自动就好了<br>不会的可以评论，我跟你解答</p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
          <category> v2ray </category>
          
          <category> 外网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用springBoot创建一个简单的helloWorld运行</title>
      <link href="posts/541bf5af.html"/>
      <url>posts/541bf5af.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用springBoot创建一个简单的helloWorld运行</strong></p><h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a><strong>一、Spring Boot 入门</strong></h1><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote><p>简化Spring应用开发的一个框架；</p><p>整个Spring技术栈的一个大整合；</p><p>J2EE开发的一站式解决方案；</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa">详细参照微服务文档</a></p><h3 id="1、MAVEN设置；"><a href="#1、MAVEN设置；" class="headerlink" title="1、MAVEN设置；"></a>1、MAVEN设置；</h3><p>给maven 的settings.xml配置文件的profiles标签添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、IDEA设置"><a href="#2、IDEA设置" class="headerlink" title="2、IDEA设置"></a>2、IDEA设置</h3><p>这里为什么用IDEA?<br>是因为IDEA使用springBoot轻松</p><p>整合maven进来；</p><p><img src="/images/搜狗截图20180129151045.png" alt="idea设置"></p><p><img src="/images/搜狗截图20180129151112.png" alt="images/"></p><h2 id="4、Spring-Boot-HelloWorld"><a href="#4、Spring-Boot-HelloWorld" class="headerlink" title="4、Spring Boot HelloWorld"></a>4、Spring Boot HelloWorld</h2><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="1、创建一个maven工程；（jar）"><a href="#1、创建一个maven工程；（jar）" class="headerlink" title="1、创建一个maven工程；（jar）"></a>1、创建一个maven工程；（jar）</h3><h3 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、编写一个主程序；启动Spring-Boot应用"><a href="#3、编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序；启动Spring Boot应用"></a>3、编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldMainApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// Spring应用启动起来</span><br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p><p>只发布了一个简单的springBoot程序，因为有很多我都没有思绪写，想跟大家分享，顺便让我自己巩固一下，之所以没有思绪是因为我想的就是将这个弄成简单化容易理解的，所以希望看到我博文的各位能帮我提出意见让我借鉴！</p><p><strong>在结尾给大家推荐一个<a href="https://www.springcloud.cc/spring-boot.html">中文官方文档</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> springBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven创建Hibernate5+mysql8</title>
      <link href="posts/16fcf8c4.html"/>
      <url>posts/16fcf8c4.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用Maven创建Hibernate5+mysql8，遇到的困难和错误</strong></p><a id="more"></a><p><strong>开始我们的废话连篇阶段，至于我为什么要写这篇博客，简单陈述一下，我之前一直使用的都是hibernate3+MySQL5，所以很多更改的地方我完全不知道，以至于我上网去找就一脸懵逼，好了废话不多说，开始教程，搞起🔨</strong></p><h2 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h2><p><strong>首先申明我使用的是eclipse，所以有使用IntelliJ IDEA，那不好意思，等我以后换软件以后更新，第一步当然很简单，那就是创建maven项目，<del>这里废话一下,能看这个博客的一般都会使用maven</del>，如果不会当我没说，你可以看另一篇博客<a href="https://yangyuhou.com/2020-09-01-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB(%E4%B8%80">如何创建maven项目</a>/ “百分之百可以运行的简单网络爬虫(一)”)</strong></p><p>创建完maven项目的样子如图：<img src="/images/2020-09-07_112951.png" alt="链接"></p><hr><h2 id="会创建maven项目的，可以直接复制下面的pom-xml的代码，也可以直接去我的-GitHub仓库-直接下载"><a href="#会创建maven项目的，可以直接复制下面的pom-xml的代码，也可以直接去我的-GitHub仓库-直接下载" class="headerlink" title="会创建maven项目的，可以直接复制下面的pom.xml的代码，也可以直接去我的 GitHub仓库 直接下载"></a>会创建maven项目的，可以直接复制下面的pom.xml的代码，也可以直接去我的 <a href="https://github.com/yang121hao/Demo">GitHub仓库</a> 直接下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br>  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br><br>  &lt;groupId&gt;com.hub&lt;&#x2F;groupId&gt;<br>  &lt;artifactId&gt;Hibernate&lt;&#x2F;artifactId&gt;<br>  &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;<br>  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;<br><br>  &lt;name&gt;Hibernate&lt;&#x2F;name&gt;<br>  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;<br><br>  &lt;properties&gt;<br>    &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;<br>  &lt;&#x2F;properties&gt;<br><br>  &lt;dependencies&gt;<br>    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;antlr&#x2F;antlr --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;antlr&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;antlr&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.7.7&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;net.bytebuddy&#x2F;byte-buddy --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;net.bytebuddy&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;byte-buddy&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.10.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.fasterxml&#x2F;classmate --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;classmate&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.5.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.dom4j&#x2F;dom4j --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.dom4j&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;dom4j&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.1.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.sun.xml.fastinfoset&#x2F;FastInfoset --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.sun.xml.fastinfoset&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;FastInfoset&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.2.15&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.hibernate&#x2F;hibernate-core --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;hibernate-core&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;5.4.1.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.hibernate.common&#x2F;hibernate-commons-annotations --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.common&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;hibernate-commons-annotations&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;5.1.0.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.sun.istack&#x2F;istack-commons-runtime --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.sun.istack&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;istack-commons-runtime&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;3.0.7&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jboss&#x2F;jandex --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jandex&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.1.1.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.javassist&#x2F;javassist --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.javassist&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;javassist&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;3.24.0-GA&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.activation&#x2F;javax.activation-api --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;javax.activation&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;javax.activation-api&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.2.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.persistence&#x2F;javax.persistence-api --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;javax.persistence&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;javax.persistence-api&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.xml.bind&#x2F;jaxb-api --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;javax.xml.bind&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jaxb-api&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.3.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.glassfish.jaxb&#x2F;jaxb-runtime --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jaxb&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jaxb-runtime&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.3.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jboss.logging&#x2F;jboss-logging --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss.logging&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jboss-logging&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;3.3.2.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jboss.spec.javax.transaction&#x2F;jboss-transaction-api_1.2_spec --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss.spec.javax.transaction&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jboss-transaction-api_1.2_spec&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.1.1.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jvnet.staxex&#x2F;stax-ex --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jvnet.staxex&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;stax-ex&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.8&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.glassfish.jaxb&#x2F;txw2 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jaxb&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;txw2&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.3.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;8.0.12&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.hibernate.javax.persistence&#x2F;hibernate-jpa-2.1-api --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.javax.persistence&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.0.0.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br><br><br>  &lt;&#x2F;dependencies&gt;<br>&lt;&#x2F;project&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="创建数据库文件"><a href="#创建数据库文件" class="headerlink" title="创建数据库文件"></a>创建数据库文件</h2><p>在数据库中创建表，MySQL的下载安装，百度谷歌一大把，我就不阐述了，用nivacat创建表</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/2020-09-07_113458.png" alt="链接"></h2><p>也可以用命令行创建，首先准备数据库test<br><code>create database test;</code><br>创建表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">use test;<br> <br>CREATE TABLE product_ (<br>  id int(11) NOT NULL AUTO_INCREMENT,<br>  name varchar(30) ,<br>  price float ,<br>  PRIMARY KEY (id)<br>) DEFAULT CHARSET&#x3D;UTF8;<br></code></pre></td></tr></table></figure></p><h2 id="创建实体类和实体类映射文件"><a href="#创建实体类和实体类映射文件" class="headerlink" title="创建实体类和实体类映射文件"></a>创建实体类和实体类映射文件</h2><p>实体类的 getter（）和 setter（）方法一定要遵循—-&gt;&gt;&gt;JavaBean规则&lt;&lt;&lt;—- 否则会报错！！！<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Product &#123;<br><br>public int id;<br>public String name;<br>public float price;<br><br>public void setId(int id) &#123;<br>this.id &#x3D; id;<br>&#125;<br><br>public int getId() &#123;<br>return id;<br>&#125;<br><br>public void setName(String name) &#123;<br>this.name &#x3D; name;<br>&#125;<br><br>public String getName() &#123;<br>return name;<br>&#125;<br><br>public void setPrice(float price) &#123;<br>this.price &#x3D; price;<br>&#125;<br><br>public float getPrice() &#123;<br>return price;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>在实体类目录下新建一个配置文件：右键entity -&gt; New -&gt; Other -&gt; General -&gt; File -&gt; Next -&gt; 文件命名：Product.hbm.xml：P一定要大写，要和实体类 Product 保持一致<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version &#x3D; &quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;<br>&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;<br>          <br>&lt;!-- 实体类包名，输入自己的项目实体包名即可 --&gt;<br>&lt;hibernate-mapping package&#x3D;&quot;pojo&quot;&gt;<br>    &lt;!-- 实体类名及数据库表名 --&gt;<br>    &lt;class name &#x3D; &quot;Product&quot; table &#x3D; &quot;product&quot;&gt;<br>          &lt;!-- 实体类属性id映射数据库表里的id --&gt;<br>          &lt;id name &#x3D; &quot;id&quot; column &#x3D; &quot;id&quot;&gt;<br>              &lt;!-- &lt;generator class&#x3D;&quot;native&quot;&gt; 意味着id的自增长方式采用数据库的本地方式 --&gt;<br>              &lt;generator class &#x3D; &quot;native&quot;&#x2F;&gt;<br>          &lt;&#x2F;id&gt;<br>          &lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&gt;&lt;&#x2F;property&gt;<br>          &lt;property name&#x3D;&quot;price&quot; column&#x3D;&quot;price&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;class&gt;<br>&lt;&#x2F;hibernate-mapping&gt;<br></code></pre></td></tr></table></figure><br>在src类目录下新建一个配置文件：右键src -&gt; New -&gt; Other -&gt; General -&gt; File -&gt; Next -&gt; 文件命名：hibernate.cfg.xml</p><p>设置hibernate.cfg.xml文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;<br>&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;<br><br>&lt;hibernate-configuration&gt;<br>       &lt;session-factory&gt;<br>       &lt;!-- Database connection setting --&gt;<br>            &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.cj.jdbc.Driver&lt;&#x2F;property&gt;<br>            &lt;!-- 由于采用的是mysql8,在url配置上要加入属性信息 ?useSSL&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai --&gt;<br>&lt;!--3306&#x2F;后面的为您的数据库名，如若不是和我一样的，修改为您的数据库名--&gt;<br>            &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC&lt;&#x2F;property&gt; <br> &lt;!--此处root修改为您的数据库用户名--&gt;<br>            &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt;<br>&lt;!--此处123456修改为您的数据库密码 --&gt;<br>            &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;123456&lt;&#x2F;property&gt; <br>            &lt;!-- SQL dialect --&gt;<br>            &lt;!--方言的配置要使用MySQL8Dialect，如果是MySQLDialect就无法自动创建表 --&gt;<br>            &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;&#x2F;property&gt;<br>            &lt;property name&#x3D;&quot;current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt;<br>            &lt;!-- 这表示是否在控制台显示执行的SQL语句 --&gt;<br>            &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt;<br>            &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt;<br>            <br>            &lt;!-- 自动更新表结构,没有表也会自动创建 --&gt;<br>            &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt;       <br>            &lt;mapping resource&#x3D;&quot;pojo&#x2F;Product.hbm.xml&quot;&#x2F;&gt;<br>       &lt;&#x2F;session-factory&gt;<br>&lt;&#x2F;hibernate-configuration&gt;<br></code></pre></td></tr></table></figure><h2 id="创建hibernate测试类"><a href="#创建hibernate测试类" class="headerlink" title="创建hibernate测试类"></a>创建hibernate测试类</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.cfg.Configuration;<br>import pojo.Product;<br><br>&#x2F;**<br> * hibernate的基本步骤是：<br>1. 获取SessionFactory<br>2. 通过SessionFactory 获取一个Session<br>3. 在Session基础上开启一个事务<br>4. 通过调用Session的save方法把对象保存到数据库<br>5. 提交事务<br>6. 关闭Session<br>7. 关闭SessionFactory<br> *&#x2F;<br>public class TestHibernate &#123;<br>public static void main(String[] args) &#123;<br>&#x2F;&#x2F;1、加载Hibernate的核心配置文件：hibernate.cfg.xml<br>Configuration configuration &#x3D; new Configuration().configure();<br>&#x2F;&#x2F;2、创建一个SessionFactory对象：类似于JDBC中的连接池<br>SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();<br>&#x2F;&#x2F;3、通过SessionFactory获取Session对象：类似JDBC中的Connection<br>Session session &#x3D; sessionFactory.openSession();<br>&#x2F;&#x2F;4、手动开启事务<br>Transaction transaction &#x3D; session.beginTransaction();<br>&#x2F;&#x2F;5、编写代码<br><br>for (int i &#x3D; 1; i &lt;&#x3D;10; i++) &#123;<br>Product p &#x3D; new Product();<br>p.setName(&quot;iphone&quot;+i);<br>p.setPrice(1000*i);<br>session.save(p);<br>&#125;<br>&#x2F;&#x2F;6、事务提交<br>transaction.commit();<br>&#x2F;&#x2F;7、资源释放<br>session.close();<br>sessionFactory.close();<br><br><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre><h2 id="测试成功图"><a href="#测试成功图" class="headerlink" title="测试成功图"></a>测试成功图</h2><p><img src="/images/2020-09-07_115010.png" alt="链接"></p><p><img src="/images/2020-09-07_115115.png" alt="链接"></p>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Hibernate </tag>
            
            <tag> mysql8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百分之百可以运行的简单网络爬虫(一)</title>
      <link href="posts/53627.html"/>
      <url>posts/53627.html</url>
      
        <content type="html"><![CDATA[<p><strong>消失了许久，因为自身的一些事情，导致自己长时间未更新博客。我知道对于学习计算机的人来说大家都有研究过爬虫，有时候需要网上不停的找教程，找思路，我呢，也在最近发现了一个事情,大佬们在网上发的教程有很多都不没有更新，还不算太完善，于是乎，我就自己研究顺带写这么一篇博客</strong></p><a id="more"></a><h2 id="制作一个简单的网络爬虫，爬取网站中的图片"><a href="#制作一个简单的网络爬虫，爬取网站中的图片" class="headerlink" title="制作一个简单的网络爬虫，爬取网站中的图片"></a>制作一个简单的网络爬虫，爬取网站中的图片</h2><p><strong>起因是因为我想找一些动漫图片，可是一个一个下载，太慢了所以脑子有个想法就是写一个简单的网络爬虫，这个是最简单最简单的爬虫，使用的是.net去获取，咱们先从最简单的开始，后续会慢慢跟进，下面先奉上代码，之后一一讲解</strong><br>可以直接去我的<a href="https://github.com/yang121hao/Demo">GitHub仓库</a> 直接下载<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import java.io.*;<br>import java.net.URLConnection;<br>import java.util.ArrayList;<br>import java.util.List;<br>import java.net.URL;<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br><br><br>public class MyJavaDeom &#123;<br><br>    &#x2F;&#x2F;网站地址<br>    private static final String URL &#x3D; &quot;https:&#x2F;&#x2F;www.jder.net&#x2F;mantu?post_order&#x3D;comments&quot;;<br>    &#x2F;&#x2F;匹配图片的正则表达式<br>    private static final String IMGURL_REG &#x3D; &quot;data-src&#x3D;(.*?)[^\&quot;]* &quot;;<br>    &#x2F;&#x2F; 获取src路径的正则<br>    private static final String IMGSRC_REG &#x3D; &quot;[a-zA-z]+:&#x2F;&#x2F;[^\\s]*&quot;;<br><br>    public static void main(String[] args)&#123;<br>        try &#123;<br>            MyController cm &#x3D; new MyController();<br>            &#x2F;&#x2F;获取HTML内容<br>            String HTML &#x3D; cm.getHtml(URL);<br>&#x2F;&#x2F;            System.out.println(HTML);<br>            &#x2F;&#x2F;获取图片标签<br>            List&lt;String&gt; imgUrl &#x3D; cm.getImageUrl(HTML);<br>            &#x2F;&#x2F;获取图片src地址<br>            List&lt;String&gt; imgSrc &#x3D; cm.getImageSrc(imgUrl);<br>            &#x2F;&#x2F;下载图片<br>            cm.Download(imgSrc);<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    &#x2F;&#x2F;获取HTML内容<br>    private String getHtml(String url)throws Exception&#123;<br>        URL url1 &#x3D; new URL(url);<br>        URLConnection connection &#x3D; url1.openConnection();<br>        InputStream in &#x3D; connection.getInputStream();<br>        InputStreamReader isr &#x3D; new InputStreamReader(in);<br>        BufferedReader br &#x3D; new BufferedReader(isr);<br><br>        String line;<br>        StringBuffer sb &#x3D; new StringBuffer();<br>        while((line &#x3D; br.readLine())!&#x3D;null)&#123;<br>            sb.append(line,0,line.length());<br>            sb.append(&#39;\n&#39;);<br>        &#125;<br>        br.close();<br>        isr.close();<br>        in.close();<br>        return sb.toString();<br>    &#125;<br><br>    &#x2F;&#x2F;获取ImageUrl地址<br>    private List&lt;String&gt; getImageUrl(String html)&#123;<br>        Matcher matcher&#x3D; Pattern.compile(IMGURL_REG).matcher(html);<br>        List&lt;String&gt; listimgurl &#x3D; new ArrayList&lt;String&gt;();<br>        while (matcher.find())&#123;<br>            listimgurl.add(matcher.group());<br>        &#125;<br>        return listimgurl;<br>    &#125;<br><br>    &#x2F;&#x2F;获取ImageSrc地址<br>    private List&lt;String&gt; getImageSrc(List&lt;String&gt; listimageurl)&#123;<br>        List&lt;String&gt; listImageSrc&#x3D;new ArrayList&lt;String&gt;();<br>        for (String image:listimageurl)&#123;<br>            Matcher matcher&#x3D;Pattern.compile(IMGSRC_REG).matcher(image);<br>            while (matcher.find())&#123;<br>                listImageSrc.add(matcher.group().substring(0, matcher.group().length()-1));<br>            &#125;<br>        &#125;<br>        return listImageSrc;<br>    &#125;<br><br>    &#x2F;&#x2F;下载图片<br>    private void Download(List&lt;String&gt; listImgSrc) &#123;<br>        try &#123;<br>            for (String url : listImgSrc) &#123;<br>                String imageName &#x3D; url.substring(url.lastIndexOf(&quot;&#x2F;&quot;) + 1, url.length());<br><br>                URL uri &#x3D; new URL(url);<br>                InputStream in &#x3D; uri.openStream();<br><br>                FileOutputStream fo &#x3D; new FileOutputStream(new File(&quot;image&#x2F;&quot;+imageName));<br>                byte[] buf &#x3D; new byte[1024];<br>                int length &#x3D; 0;<br>                while ((length &#x3D; in.read(buf, 0, buf.length)) !&#x3D; -1) &#123;<br>                    fo.write(buf, 0, length);<br>                &#125;<br>                in.close();<br>                fo.close();<br>                System.out.println(uri + &quot;下载完成&quot;);<br>            &#125;<br>        &#125; catch (Exception e) &#123;<br>            System.out.println(&quot;下载失败&quot;);<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><p><strong>需要更改的地方我用图片贴粗来</strong><br><img src="/images/2020-09-01_111547.png" alt="链接"></p><blockquote><p>网站地址就是你正在浏览的这个网页复制到网站地址中<br>匹配图片的正则表达式这一行中需要修改的是引号中的字符串，关于正则表达式可以查看<a href="">正则表达式的入门</a><br>获取src路径一般是不需要更改的</p></blockquote><p><img src="/images/2020-09-01_113102.png" alt="链接"><br>修改你要保存的文件夹地址，因为我这个只是简单的爬虫，所以没有创建文件夹这选项，需要手动创建，我将图片直接下载至<code>src</code>目录下的<code>image</code>的文件夹中，您想下载其余文件夹就需要修改成这种形式 <code>&quot;D:\\deom\\&quot;</code>，其余都不要去修改，原理就是阐述一遍，第一步，这个程序运行以后会去html页面解析，去页面中寻找您写在前面的正则表达式，正则表达式一般后面就是src地址，运行下载，将文件下载你附属的文件夹</p><h2 id="关于html页面的获取"><a href="#关于html页面的获取" class="headerlink" title="关于html页面的获取"></a>关于html页面的获取</h2><blockquote><p>上述所说的所有都只是这个程序运行的结果和修改位置，接下来所说的都是比较重要的，因为你能不能将图片爬取这一步就不能错，否则不管怎么样都是无法爬取的<br><strong>获取正则的步骤</strong><br>将你的网页打开，按<code>F12</code>一般只要按<code>F12</code>都能打开，如若打不开，谷歌内核的可以看下面这个图片<br><img src="/images/2020-09-01_114439.png" alt="链接"></p><p>打开以后，接下来就很简单，找到小鼠标，点击小鼠标让它变成蓝色。<img src="/images/2020-09-01_114756.png" alt="链接"> </p><blockquote><p>用蓝色样式点击图片会直接跳转到图片链接。<img src="/images/2020-09-01_115205.png" alt="链接"></p></blockquote></blockquote><p><strong>这样操作完以后继续下一步</strong></p><blockquote><p>跳转到链接以后会出现一个<img src="/images/2020-09-01_115538.png" alt="链接"><strong>到这一步基本上就要结束了</strong>将class后面的<code>data-src</code>复制粘贴到正则表达式里面,或许还有人会问，这后面没有<code>data-src</code>怎么办，就像下面这种<br><img src="/images/2020-09-01_140055.png" alt="链接"> 这种就只需要将<code>src</code>放入</p><p>或者大家打开以后会遇到如下格式的样式<code>/uploads/allimg/200604/001849-15912011295e8a.jpg</code>这种格式是我下一篇需要讲解的，这里面需要将这个链接拆分以后去获取，只需要大家将我的代码复制以后，修改里面我提到的东西，一般的网站都是可以爬取的。</p></blockquote><p><strong>如果这篇博客帮到您了，帮忙转发一下，让更多的人看到，不会的评论区告诉我，或者说您有更好的想法也可以告诉我</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java爬虫实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java爬虫 </tag>
            
            <tag> Java爬虫实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统期末复习材料</title>
      <link href="posts/34379.html"/>
      <url>posts/34379.html</url>
      
        <content type="html"><![CDATA[<p><strong>分布式系统期末复习材料都有哪些！</strong></p><a id="more"></a><ol><li>分布式系统的定义、特点及主要设计目标；</li><li>分布式系统透明性主要包括哪几方面？并简要描述。</li><li>策略和机制有什么不同？</li><li>分布式系统的可扩展性包括哪些方面？有哪些技术可以实现可扩展性。</li><li>集群系统和网格之间的区别；</li><li>云计算作为一种新的计算模式适用于所有企业？</li><li>主要的软件体系结构包括哪几种？</li><li>主要的系统体系结构包括哪几种？与软件体系结构的主要区别是什么？</li><li><p>分布式的分层结构</p></li><li><p>非集中化的体系结构主要类型包括哪些？</p></li><li>Chord 结构的生成和查找；</li><li>非结构化的点对点系统搜索内容的方式？</li><li>什么是超级对等节点？如何确定超级节点？</li><li>在 P2P 系统中节点之间连接的方式；</li><li>分布式系统的自我管理；</li><li>分布式系统中为什么利用线程而不是进程？</li><li>虚拟机化主要包含哪些方式，简要描述？</li><li>在客户端-服务器模型中，服务器的状态主要分为几种，简要解释。</li><li>简述如何实现代码迁移？如何区分强迁移和弱迁移？</li><li>虚拟机迁移的种类及主要特点？</li><li>RPC 远程过程调用的概念及主要步骤</li><li>使用 socket 进行网络通信的主要模式及主要过程</li><li>什么是点对点通信、广播和多播？</li><li>简述 Gossip 数据通信和反熵通信模型？</li><li>简述 SSP 即转发指针的工作原理？</li><li>Chord 指纹表的查找过程，节点如何加入和退出指纹表？</li><li>简述在树结构目录中查询实体及插入实体的过程？</li><li>名称解析闭包？</li><li>实体的硬链接和软链接？</li><li>什么是挂接点和挂载点？</li><li>什么是命名空间，命名空间的分层结构主要由哪几部分构成？</li><li>迭代命名解析和递归命名解析？</li><li>瞬时同步通信的主要问题以及解决方案？</li><li>时钟同步：内同步和外同步；</li><li>如何在没有 UTC 的情况下保障时间的准确性？</li><li>逻辑时钟？及算法</li><li>什么是全序广播？</li><li>如何利用 Lamport 逻辑时钟解决互斥访问及临界区访问？</li><li>因果有序的多播传播？</li><li>解决分布式系统中多进程互斥的方法？</li><li>Ricart &amp; Agrawala 互斥算法？</li><li>选举算法（Bully、Ring）；</li><li>无线网络中的选举算法；</li><li>数据一致性模型</li><li>连续一致性或者一致性程度主要包含哪些方面？</li><li>什么是顺序一致性和因果一致性？</li><li>数据为中心的一致性和客户为中心的一致性模型各自适用于什么场景？</li><li>什么是最终一致性？有什么优缺点？</li><li>读写一致性？写读一致性？</li><li>服务器副本的放置位置？</li><li>内容分发的方式有哪些？ Pull-based 和 Push-based 的内容分发方法有什么不同？</li><li>在一致性协议中， 如何限定数值偏差？ 限制新旧偏差？</li><li>基于主备协议的复制协议主要包括哪两种方式？分别有什么特点？</li><li>如何理解基于团体的复制写协议？</li><li>什么是可依赖性？与可依赖性相关的需求包括哪些方面？</li><li>可靠性与可用性的定义及区别？</li><li>分布式系统中主要包含哪些失效模型？简要描述。</li><li>分布式系统中冗余的主要方式有哪些？</li><li>在分布式系统中如何检测失效？</li><li>如何设计可靠的 RPC 通信机制？</li><li>什么是可靠多播？可靠多播存在的问题？</li><li>简述两阶段提交协议？ 在参与者失效时如何恢复？ 协作者失效时如何恢复？</li><li>分布式系统失效恢复的主要方式？</li><li>什么是检查点方法？</li><li>独立检查点方法？协调检查点方法？</li><li>什么是共识？主要的共识协议有哪些？</li><li>Paxos 的主要过程？ Paxos 的主要变种？</li><li>NFS 文件系统的主要架构？</li><li>GFS 文件系统的主要特点？</li><li>什么是文件系统语义模型？主要的语义模型包括哪些？简要描述其特征。</li><li>拜占庭容错的基本思想及基本过程？</li><li>P2P 系统中用于提高系统可用性的方案？以及方案的主要特点。</li><li>在分布式文件系统中主要关注的问题包括哪些？并分别给出一些解决问题的方案。</li><li>分布式机器学习的参数服务器如何理解？</li><li>如何保障参数服务状态的一致性？</li><li>如何加快机器学习特别是深度学习的过程？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于request获取不到前端form表单的值</title>
      <link href="posts/59292.html"/>
      <url>posts/59292.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在研究完两个框架以后，脑子一热就想着去将底层的web框架servlet复习一遍，就发现一个问题，就是获取不到form表单数据，然后我又上网上搜索查找!下面就是我查找的问题原因!</strong></p><a id="more"></a><p>问题：<strong>servlet中使用request.getParameter()获取不到前端发送的form表单数据</strong></p><p><strong>Post请求接收到了，利用system.out.println()输出，后台显示一直为“null”，数据为空，我一直以为是自己后台写错了</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">protected void doPost(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException &#123;<br>request.setCharacterEncoding(&quot;UTF-8&quot;);<br>response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);<br>String userid &#x3D; request.getParameter(&quot;userid&quot;);<br>String name &#x3D; request.getParameter(&quot;name&quot;);<br>String pwd &#x3D; request.getParameter(&quot;passWord&quot;);<br>String sex &#x3D; request.getParameter(&quot;sex&quot;);<br>String year &#x3D; request.getParameter(&quot;birthday&quot;);<br>String email &#x3D; request.getParameter(&quot;email&quot;);<br>String mobile &#x3D; request.getParameter(&quot;mobile&quot;);<br>String address &#x3D; request.getParameter(&quot;address&quot;);<br>Manage_User u &#x3D; new Manage_User(userid, name, pwd, sex, year, null, email, mobile, address, 1);<br>System.out.println(userid);<br>System.out.println(name);<br>System.out.println(pwd);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>结果是自己的前端表单中的问题，自己在网上找的一份模板，很早之前里面是带着上传文件的所以别人在form表单中添加”enctype=”multipart/form-data”</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;form action&#x3D;&quot;&#x2F;shopinngP&#x2F;manage&#x2F;admin_douseradd&quot; method&#x3D;&quot;post&quot; id&#x3D;&quot;myform&quot; name&#x3D;&quot;myform&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;<br>&lt;table class&#x3D;&quot;insert-tab&quot; width&#x3D;&quot;100%&quot;&gt;<br>&lt;tbody&gt;<br>&lt;tr&gt;<br>&lt;th&gt;&lt;i class&#x3D;&quot;require-red&quot;&gt;*&lt;&#x2F;i&gt;用户名：&lt;&#x2F;th&gt;<br> &lt;td&gt;<br> &lt;input class&#x3D;&quot;common-text required&quot; id&#x3D;&quot;title&quot; name&#x3D;&quot;userid&quot; size&#x3D;&quot;50&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;text&quot;&gt;<br>&lt;&#x2F;td&gt;<br>&lt;&#x2F;tr&gt;<br><br>所以导致后台输出的时候一直都是“null”，当把<br>&quot;enctype&#x3D;&quot;multipart&#x2F;form-data&quot;删除以后，就能正常输出！<br><br>&lt;form action&#x3D;&quot;&#x2F;shopinngP&#x2F;manage&#x2F;admin_douseradd&quot; method&#x3D;&quot;post&quot; id&#x3D;&quot;myform&quot; name&#x3D;&quot;myform&quot;&gt;<br>&lt;table class&#x3D;&quot;insert-tab&quot; width&#x3D;&quot;100%&quot;&gt;<br>&lt;tbody&gt;<br>&lt;tr&gt;<br>&lt;th&gt;&lt;i class&#x3D;&quot;require-red&quot;&gt;*&lt;&#x2F;i&gt;用户名：&lt;&#x2F;th&gt;<br> &lt;td&gt;<br> &lt;input class&#x3D;&quot;common-text required&quot; id&#x3D;&quot;title&quot; name&#x3D;&quot;userid&quot; size&#x3D;&quot;50&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;text&quot;&gt;<br>&lt;&#x2F;td&gt;<br>&lt;&#x2F;tr&gt;<br></code></pre></td></tr></table></figure><p><strong>我也很好奇为什么去掉就好了，去查找之后明白了，这是因为”enctype=”application/x-ww-form-urlencoded” 是默认的编码方式，当以这种方式提交数据时，HTTP报文中的内容是</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;span style&#x3D;&quot;font-size: small;&quot;&gt;POST &#x2F;post_test.php HTTP&#x2F;1.1 <br><br>Accept-Language: zh-CN<br><br>User-Agent: Mozilla&#x2F;4.0 <br><br>Content-Type: application&#x2F;x-www-form-urlencoded <br><br>Host: 192.168.12.102<br><br>Content-Length: 42<br><br>Connection: Keep-Alive<br><br>Cache-Control: no-cache<br><br>title&#x3D;test&amp;content&#x3D;%B3%AC%BC%B6%C5%AE%C9%FA&amp;submit&#x3D;post+article <br><br>&lt;&#x2F;span&gt;<br><br></code></pre></td></tr></table></figure><p>在传输大数据量的二进制数据时，必须将编码方式设置为”enctype=”multipart/form-data”，当以这种方式提交数据时，HTTP报文中的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;span style&#x3D;&quot;font-size: small;&quot;&gt;POST &#x2F;post_test.php?t&#x3D;1 HTTP&#x2F;1.1<br>Accept-Language: zh-CN<br>User-Agent: Mozilla&#x2F;4.0  <br>Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------7dbf514701e8<br>Accept-Encoding: gzip, deflate<br>Host: 192.168.12.102<br>Content-Length: 345<br>Connection: Keep-Alive<br>Cache-Control: no-cache<br> <br>-----------------------------7dbf514701e8<br>Content-Disposition: form-data; name&#x3D;&quot;title&quot;<br>test<br>-----------------------------7dbf514701e8<br>Content-Disposition: form-data; name&#x3D;&quot;content&quot;<br>....<br>-----------------------------7dbf514701e8<br>Content-Disposition: form-data; name&#x3D;&quot;submit&quot;<br>post article<br>-----------------------------7dbf514701e8--<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure><p>所以当form表单内容采用”enctype=”multipart/form-data”编码室，调用request。getParameter()获取不到数据</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
            <tag> java </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java web工程运行时出现400、404、405、500的问题</title>
      <link href="posts/47248.html"/>
      <url>posts/47248.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于java-web工程运行时出现400、404、405、500的问题"><a href="#关于java-web工程运行时出现400、404、405、500的问题" class="headerlink" title="关于java web工程运行时出现400、404、405、500的问题"></a>关于java web工程运行时出现400、404、405、500的问题</h2><p><strong>在写完上一篇博客之后，我去重新整合下项目，出现个极大的问题，不管我怎么该都是404，之后我就百度，谷歌查找，将所有的问题整理放到一起！</strong><br><a id="more"></a><br>服务器在处理完业务逻辑后，会响应浏览器，响应的内容包含了状态编码(数字类型)</p><p>【1】200：表示成功处理业务。</p><p>【2】400 请求出错<br>由于语法格式有误，服务器无法理解此请求。不作修改，客户程序就无法重复此请求。</p><p>【3】404：服务器处理的路径存在问题，找不到相关请求资源<br>如:</p><p>(1)在地址栏上的路径有问题(大小写不对)</p><p>(2)<url-pattern>的值与地址栏路径不一致</p><p>(3)两个servlet-name不一致<br>(4)没有部署项目</p><p>(5)项目的组织结构有问题</p><p>【4】405:容器找不到Servlet组件的service方法</p><p>(1)方法名写错</p><p>(2)方法的参数类型有问题</p><p>(3)方法的异常，返回值有问题</p><p>【5】500：容器找不到Servlet组件</p><p>(1)没有继承HttpServlet或实现Servlet接口</p><p>(2)<servlet-class>写的不对</p><p>(3)service里的逻辑出现了问题</p><p>我遇到的问题是405，故事是这样的— 我用post请求访问一个页面,我是希望将数据库的数据返回页面上，理论上直接访问,返回数据,然后解析就没事了,可是今天很无语.居然给我返回405…</p><p>问了很多人,他们给我提供了各种思路,都不奏效.最后听一个好哥们叫我试试换get请求,哎呀~~~这就解决了…</p><p>我问他这是为什么?  大概回到就是,我访问用post请求, 那么 , 当发送的url是一个具体的资源的时候, 网站应该解析的时候把整个url当作了域名解析了.  也就是说我并没有传参数给服务端, 而是直接访问服务端的具体资源, 所以要用get请求.</p><p>所以我就将doPost改为doGet就成功了</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
            <tag> java </tag>
            
            <tag> javaweb </tag>
            
            <tag> 400,404,500,405 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdowm语法</title>
      <link href="posts/22603.html"/>
      <url>posts/22603.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>写博客或者github上面的文档的，就要知道Markdown语法的重要性，不知道的朋友们也别着急，一篇博客轻松搞定Markdown语法。话说这个语法超级简单，一看就会</strong></p><a id="more"></a><p>Markdowm客户端快捷键如下表。</p><div class="table-container"><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl + B</td></tr><tr><td>斜体</td><td>Ctrl + I</td></tr><tr><td>引用</td><td>Ctrl + Q</td></tr><tr><td>插入链接</td><td>Ctrl + L</td></tr><tr><td>插入代码</td><td>Ctrl + K</td></tr><tr><td>插入图片</td><td>Ctrl + G</td></tr><tr><td>提升标题</td><td>Ctrl + H</td></tr><tr><td>有序列表</td><td>Ctrl + O</td></tr><tr><td>无序列表</td><td>Ctrl + U</td></tr><tr><td>横线</td><td>Ctrl + R</td></tr><tr><td>撤销</td><td>Ctrl + Z</td></tr><tr><td>重做</td><td>Ctrl + Y</td></tr></tbody></table></div><div class="note danger flat"><h1 id="Markdown-怎么使用？"><a href="#Markdown-怎么使用？" class="headerlink" title="Markdown 怎么使用？"></a>Markdown 怎么使用？</h1></div><blockquote><p>如果不算扩展，Markdown的语法绝对简单到让你爱不释手。</p></blockquote><p>Markdown语法主要分为如下几大部分： <strong>标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’</strong>。</p><h1 id="标题用法"><a href="#标题用法" class="headerlink" title="标题用法"></a>标题用法</h1>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdowm语法 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC和Struts2的区别</title>
      <link href="posts/43405.html"/>
      <url>posts/43405.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于SpringMVC和Struts2的区别"><a href="#关于SpringMVC和Struts2的区别" class="headerlink" title="关于SpringMVC和Struts2的区别"></a>关于SpringMVC和Struts2的区别</h2><p><strong>前段时间整合SpringMVC+spring和Struts2+spring，然后突发奇想SpringMVC和Struts2的区别大家都是MVC框架那到底之间有什么区别！</strong><br><a id="more"></a></p><ol><li><p>机制不同，SpringMVC 的入口是servlet，struts2的入口是filter</p></li><li><p>从性能上来说，SpringMVC的性能高于struts2，struts2是基于类设计的，每发一次请求就会创建一个Action实例，每个action都会被注入属性，而SpringMVC 是基于方法的设计，一个方法一个request上下文，而方法同时又跟一个URL对应</p></li><li><p>从参数上来说，SpringMVC 的方法之间基本上是独立的，独享request和response数据，请求数据通过参数获取，处理结果通过Model交回框架，方法之间不共享变量，而struts2虽然方法之间也是也是独立，但其所有Action变量是共享的，每次来了请求就创建一个Action，一个Action对象对应一个request上下文</p></li><li><p>从设计思想上来说，Struts2使用的是拦截器机制，而SpringMVC使用的是独立的AOP方式，SpringMVC使用起来更简洁</p></li><li><p>从数据验证上来说，SpringMVC处理AJAX的请求比较方便，只需要一个注解@ResponseBody，然后直接返回响应文本即可，而Struts2的验证比较繁琐</p></li></ol><ol><li>从配置上来说，在实际项目开发中使用Struts2是大多采用传统的配置文件方式，SpringMvc除了配置spring mvc<br>——servlet.xml文件外，已经是100%的零配置开发，所以在开发效率上高于struts2</li></ol><ol><li>从项目管理上来说，SpringMVC和Spring无缝组合，这个优势是Struts2无法与之相提并论</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
            <tag> java </tag>
            
            <tag> javaweb </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录自己第一次搭建github+jekyll博客</title>
      <link href="posts/24021.html"/>
      <url>posts/24021.html</url>
      
        <content type="html"><![CDATA[<div class="note danger flat"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2></div><div class="note default flat"><p><strong>最开始从来都不写博客，每次开发的错误，都无法记载，遇到同样的错误又要回头去查，一般就要浪费很久的时间，总是一个错误上面栽很久的时间，于是我想到了写博客这个东西,然后我就上网学习搭建GitHubpages+jekyll博客</strong></p></div><a id="more"></a><div class="note default flat"><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2></div><p>于是我就在百度上找搭建博客的思路，百度有很多，如CSDN，简书，于是在google上寻找，有两种方法用github+jekyll和github+hexo<br>想搭建一个足够干净、页面几乎不要有多余元素的博客，同时博客的功能还要足够丰富，满足我以下的需求：</p><div class="note default flat"><ul><li>[x] 用Markdown写博客</li><li>[x] 支持Latex公式</li><li>[x] 支持mermaid等插件</li><li>[x] 个性化Live2D</li><li>[x] 分享一些我在其他网站的个人账号</li><li>[x] 移动端适配</li><li>[x] 足够快的加载速度</li><li>[x] 访问量统计，评论互动</li></ul></div><p>其中，Live2D是我某次访问别人的博客初次见到的，感觉非常吸引人。最终的目标是去掉网页上所有多余的元素，只剩下博文和Live2D看板娘，看板娘本身还可以作为博客访问的导航，感觉会十分有新意。</p><p>）<br><div class="note default flat"><h2 id="搭建过程（不定期更新"><a href="#搭建过程（不定期更新" class="headerlink" title="搭建过程（不定期更新"></a>搭建过程（不定期更新</h2></div></p><div class="note primary no-icon flat"><p>我目前读的专业是软件方向，大部分的内容都是参考网上教程慢慢摸索的，假如对某些过程有意见和建议欢迎向我提出！</p><p>Jekyll是基于Ruby和Node.js环境的，很多依赖的包也会同时安装进来。现在，找在目录下打开终端，运行如下代码，加入新建了一个名为<code>blog</code>的文件夹，则说明安装成功了。</p></div><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">jekyll new blog<br></code></pre></td></tr></table></figure><div class="note default flat"><h3 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h3></div><p> 观察刚刚生成的博客目录，有如下的结构：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">├──_config.yml<br>├── _drafts<br>|   ├── begin-<span class="hljs-keyword">with</span>-the-crazy-ideas.textile<br>|   └── on-simplicity-<span class="hljs-keyword">in</span>-technology.markdown<br>├── _includes<br>|   ├── footer.html<br>|   └── header.html<br>├── _layouts<br>|   ├── <span class="hljs-keyword">default</span>.html<br>|   └── post.html<br>├── _posts<br>|   ├── <span class="hljs-number">2007</span><span class="hljs-number">-10</span><span class="hljs-number">-29</span>-why-every-programmer-should-play-nethack.textile<br>|   └── <span class="hljs-number">2009</span><span class="hljs-number">-04</span><span class="hljs-number">-26</span>-barcamp-boston<span class="hljs-number">-4</span>-roundup.textile<br>├── _site<br>├── .jekyll-metadata<br>└── index.html<br></code></pre></td></tr></table></figure><p>它的结构还算是比较简单清晰，详细功能如下表。</p><div class="table-container"><table><thead><tr><th>文件/目录</th><th>描述</th></tr></thead><tbody><tr><td>_config.yml</td><td>保存配置数据。很多配置选项都可以直接在命令行中进行设置，但是如果把那些配置写在这儿，就不用非要去记住那些命令了。</td></tr><tr><td>_drafts</td><td>drafts（草稿）是未发布的文章。这些文件的格式中都没有 title.MARKUP 数据。学习如何使用草稿。</td></tr><tr><td>_includes</td><td>可以加载这些包含部分到的布局或者文章中以方便重用。</td></tr><tr><td>_layouts</td><td>layouts（布局）是包裹在文章外部的模板。布局可以在 YAML 头信息中根据不同文章进行选择</td></tr><tr><td>_posts</td><td>这里放的就是的文章了。文件格式很重要，必须要符合:YEAR-MONTH-DAY-title.MARKUP。 永久链接 可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td></tr><tr><td>_data</td><td>格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是 .yml, .yaml, .json 或者 .csv ）。这些文件可以经由 ｀site.data｀ 访问。如果有一个 members.yml 文件在该目录下，就可以通过 site.data.members 获取该文件的内容。</td></tr><tr><td>_site</td><td>一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进 .gitignore 文件中。</td></tr><tr><td>.jekyll-metadata</td><td>该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到 .gitignore 文件可能是一个好注意。</td></tr><tr><td>index.html and other HTML, Markdown, Textile files</td><td>如果这些文件中包含 YAML 头信息 部分，Jekyll 就会自动将它们进行转换。当然，其他的如 .html, .markdown, .md, 或者 .textile 等在的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td></tr><tr><td>Other Files/Folders</td><td>其他一些未被提及的目录和文件如 css 还有 images 文件夹， favicon.ico 等文件都将被完全拷贝到生成的 site 中。</td></tr></tbody></table></div><div class="note default flat"><h3 id="选取模板"><a href="#选取模板" class="headerlink" title="选取模板"></a>选取模板</h3></div><div class="note success flat"><p>和丰富精美的Hexo比起来，好的Jekyll模板真的是太少了…经过漫长时间的挑选，最终选择在<a href="https://wu-kan.github.io/about">wu-kan</a> 主题的基础上修改啦。</p></div><p>这里选我自己的博客为模板，也可以在GitHub上慢慢翻一些别人的博客或模板。</p><div class="note default flat"><h3 id="发送到Github托管"><a href="#发送到Github托管" class="headerlink" title="发送到Github托管"></a>发送到Github托管</h3></div><p>把本地文件修改后，上传到博客仓库的<code>master</code>或者<code>gh-pages</code>分支即可。</p><div class="note default flat"><h3 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h3></div><blockquote><p>Update: 注意！以下移植插件的办法即将/已经过时。目前的计划（v2.3.0）是，将所有插件做成jsloader的形式，这样引用的时候只要<code>&lt;script src=&#39;/public/js/x.js&#39;&gt;&lt;/script&gt;</code>即可，可以加快页面访问速度。目前的计划是<strong>完全</strong>去掉<code>_include/</code>目录下的所有文件。</p></blockquote><p>我把博客实现的的插件基本上都封装起来了，拿走的流程都差不多：</p><div class="note info flat"><ul><li>将我博客代码仓库下<code>_includes\</code>相关文件加入你自己的<code>_includes</code></li><li>在你的<code>_config.yml</code>内加入相关配置项（如果有的话，可以参看我的）</li><li>最后在需要这个插件的地方加入<code>include语句</code>即可</li></ul></div><div class="note default flat"><h4 id="上传更新"><a href="#上传更新" class="headerlink" title="上传更新"></a>上传更新</h4></div><p>所有的所有前提一定是你要有Github的账号</p><div class="note warning flat"><p>我是利用github客户端上传，简单讲就是先将你看上的模板fork到自己的仓库，点击settings修改，将其中的XXX.github.io，XXX修改为自己的仓库名就可以</p></div><p><img src="/images/20180101112125849.png" alt="这里写图片描述"><br><img src="/images/20180101112152464.png" alt="这里写图片描述"></p><div class="note danger flat"><p>博客的文件是放在项目的_posts文件中的，这里要注意文件名称的格式，年-月-日-文章标题.markdown ，一般我们是用markdown编写文章，这种编辑方式也是非常的方便。如果还不知道markdown怎么使用的同学，可以参考</p><p>接下来就是自己学习一下markdown的语法</p><p>认识与入门：<a href="https://sspai.com/post/25137">markdown</a><br>介绍就到这里<br>这就是我搭建博客的历程！有不会的可以问我！</p></div>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> jekyll </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Jekyll框架更换为hexo框架</title>
      <link href="posts/240225.html"/>
      <url>posts/240225.html</url>
      
        <content type="html"><![CDATA[<div class="note danger flat"><h2 id="闲扯一下"><a href="#闲扯一下" class="headerlink" title="闲扯一下"></a>闲扯一下</h2></div><div class="note default flat"><p><strong>在我使用了一段时间的Jekyll博客以后发现，Jekyll框架不是太过于完美，于是乎我就上网找框架，找到了这款<a href="https://github.com/hexojs/hexo">hexo</a>框架，这里是<a href="https://hexo.io/zh-cn/">中文官方文档</a></strong></p></div><a id="more"></a><div class="note default flat"><h3 id="hexo框架的安装过程"><a href="#hexo框架的安装过程" class="headerlink" title="hexo框架的安装过程"></a>hexo框架的安装过程</h3></div><p>我知道很多人肯定是看官方文档有些晕头转向的，所以我就在这里写出来，顺便自己回顾一下这个搭建过程。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">安装前提</button></li><li class="tab"><button type="button" data-href="#test4-2">安装Git</button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>安装nodejs</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>安装Hexo相当简单，只需要先安装下列应用程序即可：</strong><br><strong><a href="https://nodejs.org/en/">nodejs</a></strong><br><strong><a href="https://git-scm.com/">Git</a></strong><br><strong>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。</strong><br><strong>如果您的电脑中尚未安装所需要的程序，请点击旁边的安装提示</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>Windows：下载并安装 git.</strong></p><p><strong>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</strong></p><p><strong>Linux (Ubuntu, Debian)：sudo apt-get install git-core</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</strong></p><p><strong>其它的安装方法：</strong></p><p><strong>Windows：通过 nvs（推荐）或者nvm 安装。</strong></p><p><strong>Mac：使用 Homebrew 或 MacPorts 安装。</strong></p><p><strong>Linux（DEB/RPM-based）：从 NodeSource 安装。</strong></p><p><strong>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</strong></p><p><strong>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ul><li>第一步，在你自己的本地 <del>(也就是你的D盘或者E盘)</del> 创建一个文件夹，用于放置博客</li><li>进入你放置博客的文件夹， <del>安装好Git以后，右键就会出现</del> 右键点击<code>Git Bash Here</code>如下图所示：<br><img src="/images/2020-09-14_173015.png" alt="这里写图片描述"></li><li><strong>所有准备的工作做完以后就可以开始安装如下</strong></li><li>使用npm安装，大家可能看到很多人使用<code>cnpm</code>对于这个我使用较少，可以自行查找<blockquote><p><code>$ npm install -g hexo-cli</code> //这个意思是全局安装<code>hexo-cli</code></p></blockquote></li><li>推荐大家全局安装，安装完以后，进入你自己创建的博客文件夹。</li><li>在这多说一句，很多人会看到初始化hexo的时候会出现<code>$ hexo init blog</code>和<code>$ cd blog</code>这两个命令，解释一下，这两个命令就是你不是在你博客文件夹打开的时候，需要你cd到你的文件夹，我这说的是笨办法，之际进入你自己创建好的文件夹初始化。<blockquote><p>使用<code>$ npm install</code> 直接初始化，初始化完成以后目录如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><p>到这里可以说你在本地安装的博客已经大功告成！恭喜你！</p></blockquote></li></ul><div class="note default flat"><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2></div><div class="note primary no-icon flat"><p>接着上面的继续，现在您已经在本地搭建好了，就会有人想着说，我搭建好了，怎么才能去将这个这个运行一下查看呢？这就是接下来的讲解。</p></div><h3 id="本地运行查看"><a href="#本地运行查看" class="headerlink" title="本地运行查看"></a>本地运行查看</h3><blockquote><p>本地运行查看很简单，只需要两个命令！</p><p><code>$ hexo clean</code></p><p><code>$ hexo s或者hexo sever</code></p></blockquote><p>第一个的意思是清理hexo,第二个是运行hexo。<br>运行以后<code>http://localhost:4000</code>复制此链接在网页查<br>如图所示：<br><img src="/images/hexo.jpg" alt="这里写图片描述"></p><p>到这里证明你的博客运行成功了！</p><div class="note default flat"><h2 id="上传GitHub"><a href="#上传GitHub" class="headerlink" title="上传GitHub"></a>上传GitHub</h2></div><div class="note success flat"><p>如果有GitHub仓库的可以直接往下看，如果没有仓库的人，跳转到大佬的<a href="https://www.jianshu.com/p/834d7cc0668d">简书</a> 查看</p></div><h2 id="文件简述"><a href="#文件简述" class="headerlink" title="文件简述"></a>文件简述</h2><div class="table-container"><table><thead><tr><th>文件/目录</th><th>描述</th></tr></thead><tbody><tr><td>_config.yml</td><td>保存配置数据。很多配置选项都可以直接在命令行中进行设置，但是如果把那些配置写在这儿，就不用非要去记住那些命令了。</td></tr><tr><td>_drafts</td><td>drafts（草稿）是未发布的文章。这些文件的格式中都没有 title.MARKUP 数据。学习如何使用草稿。</td></tr><tr><td>_posts</td><td>这里放的就是的文章了。文件格式很重要，必须要符合:YEAR-MONTH-DAY-title.MARKUP。 永久链接 可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td></tr><tr><td>_data</td><td>此文件是自己创建，后面会讲到</td></tr></tbody></table></div><p>更改博客信息，下一篇文章会讲到，此篇就是将hexo搭建本地，再部署到github</p><p>博客的文件是放在项目的_posts文件中的，这里要注意文件名称的格式，年-月-日-文章标题.markdown ，一般我们是用markdown编写文章，这种编辑方式也是非常的方便。如果还不知道markdown怎么使用的同学，可以参考</p><p>接下来就是自己学习一下markdown的语法</p><p>认识与入门：<strong><a href="https://yangyuhou.com/posts/22603.html">markdown语法</a></strong><br>介绍就到这里<br>这就是我更换hexo框架的历程！有不会的可以评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> jekyll </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
